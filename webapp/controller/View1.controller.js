sap.ui.define(
  [
    "../libs/jszip",
    "../libs/xlsx",
    "sap/m/MessageBox",
    "sap/m/PDFViewer",
    "sap/m/Token",
    "sap/ui/core/mvc/Controller",
    "sap/ui/core/Fragment",
    "sap/ui/Device",
    "sap/ui/comp/valuehelpdialog/ValueHelpDialog",
    "sap/ui/model/Filter",
    "sap/ui/model/FilterOperator",
    "sap/ui/model/json/JSONModel",
    "sap/ui/export/library",
    "sap/ui/export/Spreadsheet",
    "sap/ui/model/type/Float",
  ],
  function (
    jszip,
    xlsxjs,
    MessageBox,
    PDFViewer,
    Token,
    Controller,
    Fragment,
    Device,
    ValueHelpDialog,
    Filter,
    FilterOperator,
    JSONModel,
    library,
    Spreadsheet,
    Float
  ) {
    "use strict";

    return Controller.extend("ZTM_PREINV_STATUS.controller.View1", {
      excelSheetsData: [],
      pDialog: null,

      /**
      * Initialization function.
      * Sets up the initial table, filter bar, view model, and triggers initial search.
      */
      onInit: function () {
        this._oTable = this.byId("table");
        this._oFilterBar = this.byId("filterbar");

        const oToday = new Date();
        const oFirstDayOfMonth = new Date(
          oToday.getFullYear(),
          oToday.getMonth(),
          1
        );

        // Format dates as "dd.MM.yyyy"
        const fnFormatDate = function (oDate) {
          const day = String(oDate.getDate()).padStart(2, "0");
          const month = String(oDate.getMonth() + 1).padStart(2, "0");
          const year = oDate.getFullYear();
          return `${day}.${month}.${year}`;
        };

        const oViewModel = new JSONModel({
          editMode: false,
          filters: {
            IvCreatedOnFrom: fnFormatDate(oFirstDayOfMonth),
            IvCreatedOnTo: fnFormatDate(oToday),
            ExportStatus: [],
            PrintStatus: [],
            SfirType: [],
            SfirId: [],
            Lifecycle: [],
            TorId: [],
            TspId: [],
            Preinvoice: [],
            CreatedBy: [],
          },
        });

        this.getView().setModel(oViewModel, "view");

        // Call initial search and store snapshot
        this.onSearch(); // This will call _storeInitialData after loading
      },
      /**
      * Executes the search based on current filter bar input.
      * Builds filters manually and reads data from the OData service into the table model.
      */
      onSearch: function () {
        const oView = this.getView();
        const oFilterBar = oView.byId("filterbar");
        const oTable = oView.byId("table");
        const aFilters = [];

        oFilterBar.getAllFilterItems().forEach((oFilterItem) => {
          const sName = oFilterItem.getName();
          const oControl = oFilterBar.determineControlByFilterItem(oFilterItem);

          if (!oControl) {
            return;
          }

          // Handle MultiInput with tokens
          if (oControl instanceof sap.m.MultiInput) {
            const aTokens = oControl.getTokens();
            const aTokenFilters = [];

            aTokens.forEach((oToken) => {
              const oTokenData = oToken.data("range"); // token generated by ValueHelpDialog has this

              if (oTokenData) {
                // Token is a range condition from ValueHelpDialog
                aTokenFilters.push(new sap.ui.model.Filter({
                  path: sName,
                  operator: oTokenData.exclude ? "NE" : oTokenData.operation,
                  value1: oTokenData.value1,
                  value2: oTokenData.value2
                }));
              } else {
                // Fallback for plain tokens (manually added)
                aTokenFilters.push(new sap.ui.model.Filter(sName, "EQ", oToken.getKey() || oToken.getText()));
              }
            });

            if (aTokenFilters.length > 1) {
              aFilters.push(new sap.ui.model.Filter(aTokenFilters, false)); // OR logic
            } else if (aTokenFilters.length === 1) {
              aFilters.push(aTokenFilters[0]);
            }
          }
          // Handle date fields
          else if (["IvCreatedOnFrom", "IvCreatedOnTo", "IvInvDt"].includes(sName)) {
            const vRaw = oControl.getValue?.() || oControl.getDateValue?.();
            const vFormatted = (() => {
              if (vRaw instanceof Date) {
                return vRaw.toISOString().split("T")[0];
              }
              if (typeof vRaw === "string") {
                if (/^\d{2}[./]\d{2}[./]\d{4}$/.test(vRaw)) {
                  const [d, m, y] = vRaw.split(/[./]/);
                  return `${y}-${m}-${d}`;
                }
                if (/^\d{4}-\d{2}-\d{2}$/.test(vRaw)) {
                  return vRaw;
                }
              }
              return null;
            })();
            if (vFormatted) {
              aFilters.push(new sap.ui.model.Filter(sName, "EQ", vFormatted));
            }
          }
          // Handle plain fields
          else {
            const v = oControl.getValue?.();
            if (v) {
              aFilters.push(new sap.ui.model.Filter(sName, "EQ", v));
            }
          }
        });

        this.getOwnerComponent().getModel().read("/ItemSet", {
          filters: aFilters,
          success: (oData) => {
            const oModel = new sap.ui.model.json.JSONModel({ results: oData.results });
            oView.setModel(oModel, "table");

            setTimeout(() => {
              const oBinding = oTable.getBinding("items");
              if (oBinding) {
                oBinding.attachEventOnce("EventHandlerChange", () => {
                  this._storeInitialData();
                });
              }
            }, 0);
          },
          error: () => {
            sap.m.MessageToast.show("Error while fetching data.");
          }
        });
      },
      /**
      * Handles save action for table items.
      * Compares modified fields (Preinvoice and FsdDate) against initial snapshot and submits batch updates to OData.
      */
      onSave: async function () {
        const oTable = this.byId("table");
        const aItems = oTable.getItems();
        const oJSONModel = this.getView().getModel("table");
        const oODataModel = this.getView().getModel(); // OData model usado no onSearch
        const sBatchGroupId = "manual";

        if (!(oODataModel instanceof sap.ui.model.odata.v2.ODataModel)) {
          MessageBox.error("ODataModel is not available.");
          return;
        }

        let hasChanges = false;
        let hasError = false;
        const aChangedEntries = [];

        oODataModel.setUseBatch(true);
        oODataModel.setDeferredGroups([sBatchGroupId]);

        await Promise.all(
          aItems.map(async (oItem) => {
            const oContext = oItem.getBindingContext("table");
            if (!oContext) return;

            const sPath = oContext.getPath(); // e.g., "/0", "/1", etc.
            const oCurrent = oJSONModel.getProperty(sPath);
            const oInitial = this._mInitialData?.[sPath];

            if (!oCurrent || !oInitial) return;

            const formattedCurrentFsdDate = this.formatDateToDDMMYYYY(
              oCurrent.FsdDate
            );
            const formattedInitialFsdDate = this.formatDateToDDMMYYYY(
              oInitial.FsdDate
            );

            if (
              oCurrent.SfirId !== oInitial.SfirId ||
              oCurrent.SfirType !== oInitial.SfirType
            ) {
              return;
            }

            const bPreinvoiceChanged =
              oCurrent.Preinvoice !== oInitial.Preinvoice;
            const bFsdDateChanged =
              formattedCurrentFsdDate !== formattedInitialFsdDate;

            if (!bPreinvoiceChanged && !bFsdDateChanged) return;

            hasChanges = true;

            let fsdDate = oCurrent.FsdDate;
            let formattedDate;

            if (fsdDate instanceof Date) {
              formattedDate = this.formatDateToDDMMYYYY(fsdDate);
            } else if (typeof fsdDate === "string") {
              if (fsdDate.includes("T")) {
                // ISO format
                try {
                  const parsed = new Date(fsdDate);
                  if (isNaN(parsed)) throw new Error("Invalid date");
                  formattedDate = this.formatDateToDDMMYYYY(parsed);
                } catch (e) {
                  MessageBox.error(
                    `The FSD Id ${oCurrent.SfirId} has an invalid date format. Please use DD.MM.YYYY.`
                  );
                  hasError = true;
                  return;
                }
              } else {
                const normalized = fsdDate.trim().replace(/\//g, ".");
                const dateRegex = /^\d{2}\.\d{2}\.\d{4}$/;
                if (!dateRegex.test(normalized)) {
                  MessageBox.error(
                    `The FSD Id ${oCurrent.SfirId} has an invalid date format. Please use DD.MM.YYYY.`
                  );
                  hasError = true;
                  return;
                }
                formattedDate = normalized;
              }
            } else {
              MessageBox.error(
                `The FSD Id ${oCurrent.SfirId} has an unrecognized date format.`
              );
              hasError = true;
              return;
            }

            const oUpdated = { ...oCurrent, FsdDate: formattedDate };

            // Clean invalid fields (empty string, undefined, null)
            Object.keys(oUpdated).forEach((key) => {
              if (
                oUpdated[key] === "" ||
                oUpdated[key] === undefined ||
                oUpdated[key] === null
              ) {
                delete oUpdated[key];
              }
            });

            const sKey = oODataModel.createKey("ItemSet", {
              SfirId: oCurrent.SfirId,
              SfirType: oCurrent.SfirType,
            });

            oODataModel.update("/" + sKey, oUpdated, {
              groupId: sBatchGroupId,
            });

            aChangedEntries.push({
              path: sPath,
              originalDate: oCurrent.FsdDate,
            });
          })
        );

        if (hasError) return;

        if (!hasChanges) {
          MessageBox.information("No data has been changed.");
          return;
        }

        oODataModel.submitChanges({
          groupId: sBatchGroupId,
          success: () => {
            // Restore UI state
            aChangedEntries.forEach(({ path, originalDate }) => {
              oJSONModel.setProperty(path + "/FsdDate", originalDate);
            });

            this._storeInitialData(); // Update initial snapshot
            MessageBox.success("Changes successfully submitted.");
          },
          error: (oError) => {
            MessageBox.error("Error submitting changes.");
            console.error("OData submission error:", oError);
          },
        });
      },
      /**
      * Refreshes the table data and updates the initial snapshot (_mInitialData).
      */
      onRefresh: function () {
        const oTable = this.byId("table");
        const oBinding = oTable.getBinding("items");

        if (!oBinding) return;

        oBinding.attachEventOnce("dataReceived", () => {
          this._storeInitialData(); // only after data is fully loaded
        });

        this.onSearch();
      },
      /**
      * Toggles the edit mode for the table.
      * Also updates the icon of the edit button.
      */
      onEdit: function () {
        const oViewModel = this.getView().getModel("view");
        const bEditMode = oViewModel.getProperty("/editMode");

        // Toggle edit mode
        oViewModel.setProperty("/editMode", !bEditMode);

        // Change icon of the edit button
        const oButton = this.byId("editButton");
        oButton.setIcon(bEditMode ? "sap-icon://edit" : "sap-icon://display");
      },
      /**
      * Handles archive process for selected items.
      * Validates lifecycle and archive status before triggering backend archive logic.
      */
      onArchive: function () {
        var that = this,
          oTable = this.byId("table"),
          aSelectedItems = oTable.getSelectedItems();

        if (aSelectedItems.length === 0) {
          MessageBox.error("Select at least one line");
          return;
        }

        var aSelectedData = aSelectedItems
          .map(function (oItem) {
            var oContext = oItem.getBindingContext("table");
            return oContext ? oContext.getObject() : null;
          })
          .filter(Boolean);

        if (aSelectedData.length === 0) {
          MessageBox.error("Selected items do not contain any valid data.");
          return;
        }

        var lifecycle06Exists = aSelectedData.some(function (oObject) {
          return oObject.Lifecycle === "06-Canceled";
        });

        if (lifecycle06Exists) {
          MessageBox.error("It is not possible to archive canceled documents. Please check the selected lines.");
          return;
        }

        var alreadyArchived = aSelectedData.some(function (oObject) {
          return oObject.WebarchStatus === "Archived";
        });

        if (alreadyArchived) {
          MessageBox.confirm("Some FSD documents have already been archived. Do you want to continue?", {
            title: "Confirmation: Re-archive?",
            onClose: function (oAction) {
              if (oAction === MessageBox.Action.OK) {
                that._archiveSelectedItems(aSelectedData);
              }
            }
          });
        } else {
          that._archiveSelectedItems(aSelectedData);
        }

        // Refresh the table after short delay (optional, like in onPrint)
        setTimeout(function () {
          that.onRefresh();
        }, 4000);
      },
      /**
       * Internal method to execute the archive operation in a single OData PUT request
       * by sending concatenated SfirIds as key.
       * @param {Array} aSelectedData - Array of selected items data.
       */
      _archiveSelectedItems: function (aSelectedData) {
        var that = this;

        if (aSelectedData.length === 0) {
          MessageBox.error("Select at least one line");
          return;
        }

        var oModel = this.getOwnerComponent().getModel();

        // Extrai os SfirIds válidos
        var aSfirIds = aSelectedData
          .map(function (oItem) {
            return oItem.SfirId;
          })
          .filter(Boolean);

        if (aSfirIds.length === 0) {
          MessageBox.error("No valid SfirIds found for archive.");
          return;
        }

        // Concatena os IDs separados por vírgula
        var sConcatenatedSfirIds = aSfirIds.join(",");

        // Monta o path OData com os IDs concatenados
        var sPath = "/ArchiveSet(SfirId='" + encodeURIComponent(sConcatenatedSfirIds) + "')";

        // Payload contendo os mesmos IDs (ajuste conforme a definição no backend)
        var oPayload = {
          SfirId: sConcatenatedSfirIds
        };

        // Executa o único PUT
        oModel.update(sPath, oPayload, {
          success: function () {
            MessageBox.success("Documents were archived successfully.");
            that.onRefresh();
          },
          error: function (oError) {
            var sMsg = oError && oError.message ? oError.message : "Unknown error";
            MessageBox.error("Error archiving data: " + sMsg);
          }
        });
      },
      /**
      * Stores the current table data snapshot in _mInitialData.
      * Used to detect changes during save.
      */
      _storeInitialData: function () {
        const oTable = this.byId("table");
        const oModel = this.getView().getModel("table");
        const aItems = oTable.getItems();

        this._mInitialData = {};

        aItems.forEach((oItem) => {
          const oContext = oItem.getBindingContext("table");
          if (!oContext) return;

          const sPath = oContext.getPath();
          const oData = Object.assign({}, oModel.getProperty(sPath));

          // Convert FsdDate to string for consistent comparison
          oData.FsdDate = this.formatDateToDDMMYYYY(oData.FsdDate);

          this._mInitialData[sPath] = oData;
        });

        console.log(
          "Initial data stored in _mInitialData:",
          this._mInitialData
        );
      },
      /**
      * Formats a currency value into a string with two decimals and thousand separators.
      * @param {Number} value - Currency value.
      * @returns {String} Formatted currency.
      */
      formatCurrency: function (value) {
        if (!value) {
          return "0,00";
        }

        // Format number with 2 decimals and thousand separator (e.g., 1.234,56)
        return new Intl.NumberFormat("de-DE", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(value);
      },
      /**
      * Formats a date into "DD.MM.YYYY" string.
      * Accepts Date objects or string representations.
      * @param {Date | String} value - Date to format.
      * @returns {String} Formatted date.
      */
      formatDateToDDMMYYYY: function (value) {
        if (!value) return "";

        const oDateFormat = sap.ui.core.format.DateFormat.getDateInstance({
          pattern: "dd.MM.yyyy",
        });

        if (value instanceof Date) {
          return oDateFormat.format(value);
        }

        if (typeof value === "string") {
          const cleaned = value.trim().replace(/\//g, ".");
          const parts = cleaned.split(".");

          if (parts.length === 3) {
            const [dd, mm, yyyy] = parts;
            return `${dd.padStart(2, "0")}.${mm.padStart(2, "0")}.${yyyy}`;
          }

          return cleaned;
        }

        return "";
      },
      /**
      * Handles print action for selected table items.
      * Validates lifecycle, print status, and TspId before triggering PDF generation.
      */
      onPrint: function (oEvent) {
        var that = this,
          oTable = this.byId("table"), // Garantir que o ID da tabela é "table"
          aSelectedItems = oTable.getSelectedItems();

        // Check if there are any selected items
        if (aSelectedItems.length === 0) {
          MessageBox.error("Select at least one line");
          return;
        }

        // Retrieve the data for the selected items
        var aSelectedData = aSelectedItems
          .map(function (oItem) {
            var oContext = oItem.getBindingContext("table");
            return oContext ? oContext.getObject() : null;
          })
          .filter(Boolean); // Filter out null or invalid items

        if (aSelectedData.length === 0) {
          MessageBox.error("Selected items do not contain any valid data.");
          return;
        }

        // Validate TspId and check if the document can be printed
        var TspIdNotPrint = aSelectedData.some(function (oObject) {
          return oObject.TspId === null || oObject.TspId === undefined;
        });

        if (TspIdNotPrint) {
          MessageBox.error(
            "There is a carrier that cannot be printed, please check the selected lines"
          );
          return;
        }

        // Check if Lifecycle is '06-Canceled'
        var lifecycle06Exists = aSelectedData.some(function (oObject) {
          return oObject.Lifecycle === "06-Canceled";
        });

        if (lifecycle06Exists) {
          MessageBox.error(
            "It is not possible to print canceled documents, please check the selected documents"
          );
          return;
        }

        // Check if PrintStatus is 'Printed'
        var printStatusBExists = aSelectedData.some(function (oObject) {
          return oObject.PrintStatus === "Printed";
        });

        // Confirm reprint if PrintStatus is 'Printed'
        if (printStatusBExists) {
          MessageBox.confirm(
            "Some FSD documents have already been printed, do you want to continue?",
            {
              title: "Confirmation: Reprint?",
              onClose: function (oAction) {
                if (oAction === MessageBox.Action.OK) {
                  that._printSelectedItems(aSelectedData);
                }
              },
            }
          );
        } else {
          that._printSelectedItems(aSelectedData);
        }

        // Refresh the table after a short delay
        setTimeout(function () {
          that.onRefresh();
        }, 4000);
      },
      /**
      * Internal function that triggers PDF generation and opens it in PDFViewer.
      * @param {Array} aSelectedData - Array of selected items to print.
      */
      _printSelectedItems: function (aSelectedData) {
        var that = this;
        var oModel = this.getOwnerComponent().getModel();

        if (aSelectedData.length === 0) {
          MessageBox.error("Select at least one line");
          return;
        }

        var aSelectedItems = [];

        // Collect the SfirIds of the selected items
        aSelectedData.forEach(function (oItem) {
          if (oItem.SfirId) {
            aSelectedItems.push(oItem.SfirId);
          }
        });

        if (aSelectedItems.length > 0) {
          var concatenatedSfirIds = aSelectedItems.join(",");
          var opdfViewer = new PDFViewer();
          that.getView().addDependent(opdfViewer);

          // Build the source URL for the PDF
          var sServiceURL = oModel.sServiceUrl;
          var sSource =
            sServiceURL +
            "/PrintSet(SfirId='" +
            concatenatedSfirIds +
            "')/$value";
          opdfViewer.setSource(sSource);
          opdfViewer.setTitle("PreInvoice PDF");
          opdfViewer.open();
        } else {
          MessageBox.error("Select at least one valid line to print");
        }
      },
      /**
      * Downloads an empty Excel template file for documentation purposes.
      */
      onTempDownload: function () {
        var header = [
          { label: "FSD Type", property: "SfirType" },
          { label: "FSD Id", property: "SfirId" },
          { label: "Preinvoice Nr.", property: "Preinvoice" },
          { label: "Settlement Date", property: "FsdDate" },
          { label: "Created On", property: "CreatedOn" },
          { label: "Lifecycle", property: "Lifecycle" },
          { label: "Carrier", property: "TspId" },
          { label: "External Carrier", property: "BpExt" },
          { label: "Invoice Date", property: "InvDt" },
          { label: "Net Amount", property: "NetAmount" },
          { label: "Currency", property: "DocCurrency" },
          { label: "Admin Fee", property: "AdminFee" },
          { label: "Plan Discount", property: "PlanDisc" },
          { label: "Export Status", property: "ExportStatus" },
          { label: "Print Status", property: "PrintStatus" },
          { label: "Webarch Status", property: "WebarchStatus" },
        ];

        var aData = [{}]; // Empty data
        var oSettings = {
          workbook: { columns: header },
          dataSource: aData,
          fileName: "ECC Self-Billing documentation.xlsx",
          worker: false,
        };
        var oSheet = new sap.ui.export.Spreadsheet(oSettings);
        oSheet
          .build()
          .then(function () {
            MessageBox.success("Template Downloaded");
          })
          .finally(function () {
            oSheet.destroy();
          });
      },
      /**
      * Closes the Excel upload dialog.
      */
      onCloseDialog: function (oEvent) {
        this.pDialog.close();
      },
      /**
      * Opens the Excel upload dialog fragment for uploading Excel files.
      */
      openExcelUploadDialog: function (oEvent) {
        this.excelSheetsData = [];
        var oView = this.getView();
        if (!this.pDialog) {
          Fragment.load({
            id: "excel_upload",
            name: "ZTM_PREINV_STATUS.view.ExcelUpload",
            type: "XML",
            controller: this,
          })
            .then((oDialog) => {
              var oFileUploader = Fragment.byId("excel_upload", "uploadSet");
              oFileUploader.removeAllItems();
              this.pDialog = oDialog;
              this.pDialog.open();
            })
            .catch((error) => alert(error.message));
        } else {
          var oFileUploader = Fragment.byId("excel_upload", "uploadSet");
          oFileUploader.removeAllItems();
          this.pDialog.open();
        }
      },
      /**
      * Handles file type mismatch during file upload.
      * Shows an error message if an invalid file type is uploaded.
      */
      handleTypeMissmatch: function (oEvent) {
        var aFileTypes = oEvent.getSource().getFileType();
        aFileTypes.map(function (sType) {
          return "*." + sType;
        });
        MessageBox.error(
          "The file type *." +
          oEvent.getParameter("fileType") +
          " is not supported. Choose one of the following types: " +
          aFileTypes.join(", ")
        );
      },
      /**
      * Validates if Excel file has been uploaded and triggers backend OData processing.
      */
      onUploadSet: function (oEvent) {
        var that = this,
          oSource = oEvent.getSource();

        // checking if excel file contains data or not
        if (!this.excelSheetsData.length) {
          MessageBox.error("Select file to Upload");
          return;
        }

        that.callOdata();
        that.pDialog.close();
      },
      /**
      * Clears Excel data when an uploaded item is removed from the upload set.
      */
      onItemRemoved: function (oEvent) {
        this.excelSheetsData = [];
      },
      /**
      * Parses the uploaded Excel file and converts its content into JSON format.
      * Stores parsed data into this.excelSheetsData.
      */
      onUploadSetComplete: function (oEvent) {
        var oFileUploader = Fragment.byId("excel_upload", "uploadSet");
        var oFile = oFileUploader.getItems()[0].getFileObject();
        var reader = new FileReader();
        var that = this;

        reader.onload = (e) => {
          let xlsx_content = e.currentTarget.result;

          let workbook = XLSX.read(xlsx_content, { type: "binary" });
          var excelData = XLSX.utils.sheet_to_row_object_array(
            workbook.Sheets["Sheet1"]
          );

          workbook.SheetNames.forEach(function (sheetName) {
            that.excelSheetsData.push(
              XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName])
            );
          });
        };
        reader.readAsBinaryString(oFile);
      },
      /**
      * Calls OData service to process uploaded Excel data row by row.
      * Creates or updates records based on Excel input.
      */
      callOdata: function () {
        var oModel = this.getView().getModel();
        var aPromises = [];
        var that = this;

        this.excelSheetsData[0].forEach((value, index) => {
          var payload = {
            PREINVOICE: [
              {
                SFIR_TYPE: value["FSD Type"],
                SFIR_ID: value["FSD Id"],
                PREINVOICE: value["Preinvoice Nr."],
                FSD_DATE: value["Settlement Date"],
                CREATED_ON: value["Created On"],
                LIFECYCLE: value["Lifecycle"],
                TSP_ID: value["Carrier"],
                BPEXT: value["External Carrier"],
                INV_DT: value["Invoice Date"],
                NET_AMOUNT: value["Net Amount"],
                DOC_CURRENCY: value["Currency"],
                ADMIN_FEE: value["Admin Fee"],
                PLAN_DISC: value["Plan Discount"],
                EXPORT_STATUS: value["Export Status"],
                PRINT_STATUS: value["Print Status"],
                WEBARCH_STATUS: value["Webarch Status"],
              },
            ],
            ExcelRowNumber: index + 1
          };

          var p = new Promise((resolve, reject) => {
            oModel.create("/UploadSet", payload, {
              success: function (result) {
                var oMessageManager = sap.ui.getCore().getMessageManager();
                var oMessage = new sap.ui.core.message.Message({
                  message: "Building Created/Updated with ID: " + result.SfirId,
                  persistent: true,
                  type: sap.ui.core.MessageType.Success,
                });
                oMessageManager.addMessages(oMessage);
                resolve();
              },
              error: function (error) {
                MessageBox.error("Error processing data");
                reject();
              }
            });
          });

          aPromises.push(p);
        });

        // After all create calls are done
        Promise.all(aPromises)
          .then(() => {
            MessageBox.success("Record(s) updated successfully!");
            that.onRefresh(); // Refresh your table here
          })
          .catch(() => {
            // Optionally handle partial errors here
            MessageBox.warning("Some rows could not be processed.");
          });
      },
      /**
      * Handles Excel export for selected table items.
      * Formats data and triggers spreadsheet export including updating backend export status.
      */
      onExport: function () {
        var that = this,
          oTable = this.byId("table"),
          aSelectedItems = oTable.getSelectedItems();

        // Show error if nothing is selected
        if (aSelectedItems.length === 0) {
          MessageBox.error("Select at least one line");
          return;
        }

        // Extract data from selected items
        var aSelectedData = aSelectedItems
          .map(function (oItem) {
            var oContext = oItem.getBindingContext("table"); // Ensure model alias is correct
            return oContext ? oContext.getObject() : null;
          })
          .filter(Boolean);

        // Show error if selected items don't contain valid data
        if (aSelectedData.length === 0) {
          MessageBox.error("Selected items do not contain any valid data.");
          return;
        }

        // Helper to format "DD/MM/YYYY" or ISO to "DD.MM.YYYY"
        function formatDate(sDate) {
          if (typeof sDate === "string" && /^\d{2}\/\d{2}\/\d{4}$/.test(sDate)) {
            return sDate.replace(/\//g, ".");
          }
          try {
            var oDate = new Date(sDate);
            if (isNaN(oDate.getTime())) return "";
            var day = String(oDate.getDate()).padStart(2, "0");
            var month = String(oDate.getMonth() + 1).padStart(2, "0");
            var year = oDate.getFullYear();
            return day + "." + month + "." + year;
          } catch (e) {
            return "";
          }
        }

        // Format data to be exported to Excel
        var aFormattedData = aSelectedData.map(function (oItem) {
          return {
            SfirType: oItem.SfirType,
            SfirId: oItem.SfirId,
            Preinvoice: oItem.Preinvoice,
            FsdDate: oItem.FsdDate,
            CreatedOn: formatDate(oItem.CreatedOn),
            Lifecycle: oItem.Lifecycle,
            TspId: oItem.TspId,
            BpExt: oItem.BpExt,
            ResId: oItem.ResId,
            InvDt: formatDate(oItem.InvDt),
            NetAmount: oItem.NetAmount,
            DocCurrency: oItem.DocCurrency,
            AdminFee: oItem.AdminFee,
            PlanDisc: oItem.PlanDisc,
            ExportStatus: oItem.ExportStatus,
            PrintStatus: oItem.PrintStatus,
            WebarchStatus: oItem.WebarchStatus,
          };
        });

        // Define columns for the Excel export
        var aColumns = [
          { label: "FSD Type", property: "SfirType" },
          { label: "FSD Id", property: "SfirId" },
          { label: "Preinvoice Nr.", property: "Preinvoice" },
          { label: "Settlement Date", property: "FsdDate" },
          { label: "Created On", property: "CreatedOn" },
          { label: "Lifecycle", property: "Lifecycle" },
          { label: "Carrier", property: "TspId" },
          { label: "External Carrier", property: "BpExt" },
          { label: "Invoice Date", property: "InvDt" },
          { label: "Net Amount", property: "NetAmount", type: "number", scale: 2 },
          { label: "Currency", property: "DocCurrency" },
          { label: "Admin Fee", property: "AdminFee", type: "number", scale: 2 },
          { label: "Plan Discount", property: "PlanDisc", type: "number", scale: 2 },
          { label: "Export Status", property: "ExportStatus" },
          { label: "Print Status", property: "PrintStatus" },
          { label: "Webarch Status", property: "WebarchStatus" }
        ];

        // Start Excel file creation
        var oSpreadsheet = new sap.ui.export.Spreadsheet({
          workbook: {
            columns: aColumns,
            context: {
              sheetName: "FSD Data"
            }
          },
          dataSource: aFormattedData,
          fileName: "PreInvoice_Export.xlsx"
        });

        oSpreadsheet.build().finally(function () {
          oSpreadsheet.destroy();

          const oModel = that.getView().getModel(); // Default OData model
          let iSuccessCount = 0;
          let iErrorCount = 0;
          const iTotal = aSelectedData.length;

          aSelectedData.forEach(function (oItem) {
            const sPath = "/ExcelStatusSet(SfirId='" + encodeURIComponent(oItem.SfirId) +
              "',SfirType='" + encodeURIComponent(oItem.SfirType) + "')";

            oModel.update(sPath, {
              SfirId: oItem.SfirId,
              SfirType: oItem.SfirType
            }, {
              success: function () {
                iSuccessCount++;
                checkCompletion();
              },
              error: function (oError) {
                iErrorCount++;
                const sMsg = oError?.responseText || oError?.message || "Unknown error";
                console.log("Update failed:", sMsg);
                checkCompletion();
              }
            });
          });

          // Called after every success or error to check if we’re done
          function checkCompletion() {
            if (iSuccessCount + iErrorCount === iTotal) {
              if (iSuccessCount > 0) {
                MessageBox.success(iSuccessCount + " record(s) exported");
              }
              if (iErrorCount > 0) {
                MessageBox.error(iErrorCount + " record(s) failed to update. Check console for details.");
              }

              // Refresh only after all updates finish
              that.onRefresh();
            }
          }
        });
      },
      /**
      * Handles manual entry of tokens in MultiInput fields.
      * Adds the token both visually and to the view model filter property.
      */
      onMultiInputChange: function (oEvent) {
        const oInput = oEvent.getSource();
        const sFieldId = oInput.getId().split("--").pop(); // Ex: IvSfirType
        const sValue = oEvent.getParameter("value").trim();
        const oViewModel = this.getView().getModel("view");

        if (!sValue) {
          oInput.setValue("");
          return;
        }

        const sFilterProp = sFieldId.replace("Iv", ""); // Transforma IvSfirType => SfirType
        const aCurrentTokens = oViewModel.getProperty(`/filters/${sFilterProp}`) || [];

        const bExists = aCurrentTokens.some(
          (item) => item.key === sValue || item.text === sValue
        );
        if (bExists) {
          oInput.setValue("");
          return;
        }

        const oToken = new sap.m.Token({ key: sValue, text: sValue });
        oInput.addToken(oToken);

        aCurrentTokens.push({ key: sValue, text: sValue });
        oViewModel.setProperty(`/filters/${sFilterProp}`, aCurrentTokens);

        oInput.setValue("");
      },
      /**
      * Handles token removal from MultiInput.
      * Updates view model filter properties accordingly.
      */
      onTokenUpdate: function (oEvent) {
        if (oEvent.getParameter("type") !== "removed") return;

        const oInput = oEvent.getSource();
        const sFieldId = oInput.getId().split("--").pop(); // Ex: IvSfirType
        const sFilterProp = sFieldId.replace("Iv", "");    // => SfirType

        const aRemovedTokens = oEvent.getParameter("removedTokens");
        const oViewModel = this.getView().getModel("view");
        let aCurrentTokens = oViewModel.getProperty(`/filters/${sFilterProp}`) || [];

        aRemovedTokens.forEach((token) => {
          aCurrentTokens = aCurrentTokens.filter(
            (item) => item.key !== token.getKey()
          );
        });

        oViewModel.setProperty(`/filters/${sFilterProp}`, aCurrentTokens);
      },
      /**
      * Provides suggestion filtering for ExportStatus and PrintStatus inputs.
      * Filters suggestion items based on input.
      */
      onSuggestStatus: function (oEvent) {
        const sTerm = oEvent.getParameter("suggestValue");
        const oInput = oEvent.getSource();

        const oFilter = new sap.ui.model.Filter({
          filters: [
            new sap.ui.model.Filter("Code", sap.ui.model.FilterOperator.Contains, sTerm),
            new sap.ui.model.Filter("Text", sap.ui.model.FilterOperator.Contains, sTerm),
          ],
          and: false,
        });

        oInput.getBinding("suggestionItems").filter(oFilter);
      },
      /**
      * Opens a generic Value Help Dialog for ExportStatus or PrintStatus.
      * Loads available values from the backend using OData.
      * @param {String} sFieldId - Field ID of the input.
      * @param {String} sModelPath - OData path to load suggestions from.
      */
      handleF4StatusDialog: function (sFieldId, sModelPath) {
        const oMultiInput = this.byId(sFieldId);
        const sQuery = oMultiInput.getValue();
        const oModel = this.getView().getModel();
        const oViewModel = this.getView().getModel("view");

        const sFilterProp = sFieldId === "IvPrintStatus" ? "PrintStatus" : "ExportStatus";
        const sDialogProp = `_oValueHelpDialog${sFilterProp}`;

        const aFilters = sQuery ? [
          new sap.ui.model.Filter({
            filters: [
              new sap.ui.model.Filter("Code", sap.ui.model.FilterOperator.Contains, sQuery),
              new sap.ui.model.Filter("Text", sap.ui.model.FilterOperator.Contains, sQuery),
            ],
            and: false,
          })
        ] : [];

        const aExistingData = oViewModel.getProperty(`/filters/${sFilterProp}`) || [];
        const aExistingTokens = aExistingData.map((item) => new sap.m.Token({ key: item.key, text: item.text }));

        if (!aExistingTokens.length) {
          oMultiInput.removeAllTokens();
          oViewModel.setProperty(`/filters/${sFilterProp}`, []);
        }

        if (!this[sDialogProp]) {
          this[sDialogProp] = new sap.ui.comp.valuehelpdialog.ValueHelpDialog("", {
            title: sFilterProp === "PrintStatus" ? "Printed?" : "Excel Exported?",
            supportMultiselect: true,
            supportRanges: true,
            key: "Code",
            descriptionKey: "Text",
            stretch: sap.ui.Device.system.phone,

            ok: function (oEvent) {
              const aSelectedTokens = oEvent.getParameter("tokens");
              const oUniqueMap = {};
              const aUniqueTokens = [];

              aSelectedTokens.forEach((token) => {
                if (!oUniqueMap[token.getKey()]) {
                  oUniqueMap[token.getKey()] = true;
                  aUniqueTokens.push(token);
                }
              });

              oMultiInput.setTokens(aUniqueTokens);

              const aSelected = aUniqueTokens.map((token) => ({
                key: token.getKey(),
                text: token.getText(),
              }));
              oViewModel.setProperty(`/filters/${sFilterProp}`, aSelected);

              this.close();
            },
            cancel: function () {
              this.close();
            }
          });

          const oColModel = new sap.ui.model.json.JSONModel({
            cols: [
              { label: "Code", template: "Code" },
              { label: "Description", template: "Text" },
            ],
          });

          const oTable = this[sDialogProp].getTable();
          oTable.setModel(oColModel, "columns");
          oTable.setModel(oModel);
          oTable.bindRows({ path: sModelPath, filters: aFilters });

          this[sDialogProp].setRangeKeyFields([
            { label: "Code", key: "Code" },
            { label: "Description", key: "Text" },
          ]);
        } else {
          const oTable = this[sDialogProp].getTable();
          oTable.getBinding("rows").filter(aFilters);
        }

        this[sDialogProp].setTokens(aExistingTokens);

        const oTable = this[sDialogProp].getTable();
        oTable.attachEventOnce("rowsUpdated", () => {
          oTable.clearSelection();
          const aContexts = oTable.getBinding("rows").getContexts();
          const aSelectedKeys = aExistingTokens.map((t) => t.getKey());
          const oSeenKeys = {};

          aContexts.forEach((oContext, iIndex) => {
            const sCode = oContext.getProperty("Code");
            if (sCode && !oSeenKeys[sCode] && aSelectedKeys.includes(sCode)) {
              oSeenKeys[sCode] = true;
              oTable.addSelectionInterval(iIndex, iIndex);
            }
          });
        });

        this[sDialogProp].open();
      },
      /**
      * Opens the Value Help Dialog for Export Status selection.
      */
      handleF4ExportStatus: function () {
        this.handleF4StatusDialog("IvExportStatus", "/SHExportStatusSet");
      },
      /**
      * Opens the Value Help Dialog for Print Status selection.
      */
      handleF4PrintStatus: function () {
        this.handleF4StatusDialog("IvPrintStatus", "/SHPrintStatusSet");
      },
      /**
      * Opens a generic Value Help Dialog with support for ranges and multiselect.
      * @param {String} sFieldId - Field ID of the input.
      * @param {String} sTitle - Dialog title.
      * @param {String} sPath - OData path.
      * @param {String} sKey - Key property name.
      * @param {String} sText - Text property name.
      */
      openValueHelpDialog: function (sFieldId, sTitle, sPath, sKey, sText) {
        const oView = this.getView();
        const oModel = oView.getModel();
        const oViewModel = oView.getModel("view");
        const oMultiInput = this.byId(sFieldId);
        const aTokens = oMultiInput.getTokens();

        if (!this._mValueHelpDialogs) {
          this._mValueHelpDialogs = {};
        }

        if (!this._mValueHelpDialogs[sFieldId]) {
          this.loadFragment({
            name: "ZTM_PREINV_STATUS.view.ValueHelpDialog"
          }).then(function (oDialog) {
            oDialog.setTitle(sTitle);
            oDialog.setSupportMultiselect(true);
            oDialog.setSupportRanges(true);
            oDialog.setSupportRangesOnly(true);
            oDialog.setRangeKeyFields([
              {
                label: sText,
                key: sKey,
                type: "text"
              }
            ]);

            oDialog.setTokens(aTokens);

            // Passar o ID como payload no bind para resgatar no handler
            oDialog.attachOk((oEvent) => this.onValueHelpDialogOkPress(sFieldId, oEvent));
            oDialog.attachCancel(() => this.onValueHelpDialogCancelPress(sFieldId));
            oDialog.attachAfterClose(() => this.onValueHelpDialogAfterClose(sFieldId));

            this._mValueHelpDialogs[sFieldId] = oDialog;
            oView.addDependent(oDialog);
            oDialog.open();
          }.bind(this));
        } else {
          this._mValueHelpDialogs[sFieldId].setTokens(aTokens);
          this._mValueHelpDialogs[sFieldId].open();
        }
      },
      /**
      * Handles the OK event from Value Help Dialog.
      * Updates tokens in the input and filter property in view model.
      */
      onValueHelpDialogOkPress: function (sFieldId, oEvent) {
        const oMultiInput = this.byId(sFieldId);
        const aSelectedTokens = oEvent.getParameter("tokens") || [];
        oMultiInput.setTokens(aSelectedTokens);

        const oViewModel = this.getView().getModel("view");
        const aSelectedData = aSelectedTokens.map(token => ({
          key: token.getKey(),
          text: token.getText()
        }));
        oViewModel.setProperty(`/filters/${sFieldId.replace("Iv", "")}`, aSelectedData);

        this._mValueHelpDialogs[sFieldId].close();
      },
      /**
      * Handles cancel event from Value Help Dialog.
      * Closes the dialog without applying changes.
      */
      onValueHelpDialogCancelPress: function (sFieldId) {
        this._mValueHelpDialogs[sFieldId].close();
      },
      /**
      * Handles the after close event for Value Help Dialog.
      * Destroys the dialog instance to free memory.
      */
      onValueHelpDialogAfterClose: function (sFieldId) {
        this._mValueHelpDialogs[sFieldId].destroy();
        delete this._mValueHelpDialogs[sFieldId];
      },
      /**
      * Opens the Value Help Dialog for FSD Type selection.
      */
      handleF4SfirType: function () {
        this.openValueHelpDialog("IvSfirType", "FSD Type", "/SHFsdTypeSet", "Code", "Description");
      },
      /**
      * Opens the Value Help Dialog for FSD Id selection.
      */
      handleF4SfirId: function () {
        this.openValueHelpDialog("IvSfirId", "FSD ID", "/SHFsdIdSet", "Code", "Description");
      },
      /**
      * Opens the Value Help Dialog for Lifecycle selection.
      */
      handleF4Lifecycle: function () {
        this.openValueHelpDialog("IvLifecycle", "Lifecycle", "/SHLifecycleSet", "Code", "Description");
      },
      /**
      * Opens the Value Help Dialog for Freight Order (TorId) selection.
      */
      handleF4TorId: function () {
        this.openValueHelpDialog("IvTorId", "Freight Order", "/SHTorIdSet", "Code", "Description");
      },
      /**
      * Opens the Value Help Dialog for Carrier (TspId) selection.
      */
      handleF4TspId: function () {
        this.openValueHelpDialog("IvTspId", "Carrier", "/SHTspIdSet", "Code", "Description");
      },
      /**
      * Opens the Value Help Dialog for Preinvoice number selection.
      */
      handleF4PreInvoice: function () {
        this.openValueHelpDialog("IvPreinvoice", "Preinvoice Nr.", "/SHPreInvoiceSet", "Code", "Description");
      },
      /**
      * Opens the Value Help Dialog for CreatedBy selection.
      */
      handleF4CreatedBy: function () {
        this.openValueHelpDialog("IvCreatedBy", "Created By", "/SHCreatedBySet", "Code", "Description");
      },
    });
  }
);
